✅ أهم المشاكل الحالية (لازم تتصلح)
(A) Frontend

Save Badge class ينكسر
أنت تعمل:

el.className = type;


هذا يمسح الكلاس الأساسي ويخرب الـ CSS. لازم تخلي saveBadge ثابت + تضيف الحالة.

تضيف في localStorage حتى لو API نجح، لكن ما تعيد مزامنة ID الحقيقي
الـ Backend يولّد ID مثل R-2025...
أنت محلياً تولّد ID R-<timestamp> وتخزنه، وبعدين تعمل update ممكن يفشل لأن ID مختلف.

في submit أنت ترسل payload فيه level/score/id...
الـ Backend أصلاً يحسب score/level من probability/impact. إرسالهم ما يضر لكن يسبب تضارب لو حطيت شيء غلط.

Risk و Owner و Mitigation لازم تكون من الشيت (Master/RiskLibrary)
حاليًا القوائم ثابتة داخل HTML = يتعبك ويخلي الفريق يغلط.

mode:cors في fetch GET غير لازم، وبعض الحالات يسبب تصرفات غريبة. خلّه افتراضي.

(B) Backend (Apps Script)

عندك getMetrics() لكن ما له endpoint
يعني واجهتك ما تقدر تنادي ?action=metrics.

RiskLibrary قارئ 6 أعمدة بينما المكتبة الصحيحة 4 أعمدة (Risk/Category/DefaultOwner/DefaultMitigation).
لا تخلط owner/department هنا. هذا من Master.

البحث عن ID بطيء وممكن يخون
أنت تقرأ كل IDs وتبحث. الأفضل TextFinder.

لا يوجد endpoint لـ Master
والواجهة تحتاجه عشان Dropdown owners/depts.

لا يوجد حماية بسيطة (اختياري)، بس على الأقل جهّز hook.

✅ النسخة “المليون بالمية” للـ Backend (انسخها كما هي)

ضعها في Code.gs بدل الكود كله:

/**
 * Risk Register API - Makkah Medical Complex (Al Zaher)
 * Spreadsheet: 12rii0-wE4jXD2NHS6n_6vutMiPOkTkv-A8WrCqlPo6A
 * Sheets:
 *  - RiskRegister (Data)
 *  - RiskLibrary  (Risk templates: Risk | Category | DefaultOwner | DefaultMitigation)
 *  - Master       (Owners/Departments: Owner | Department)
 */

const SPREADSHEET_ID = '12rii0-wE4jXD2NHS6n_6vutMiPOkTkv-A8WrCqlPo6A';
const SHEET_NAME = 'RiskRegister';
const LIB_SHEET = 'RiskLibrary';
const MASTER_SHEET = 'Master';

// Optional simple protection (leave empty to disable)
const WRITE_TOKEN = ''; // e.g. 'MMC2025'

function doGet(e) {
  const action = String(e?.parameter?.action || '').toLowerCase();

  if (action === 'list') return jsonOutput(listRisks());
  if (action === 'metrics') return jsonOutput(getMetrics());
  if (action === 'library') return jsonOutput(getRiskLibrary());
  if (action === 'master') return jsonOutput(getMasterList());

  return jsonOutput({
    ok: true,
    message: 'Risk Register API. Use ?action=list | metrics | library | master'
  });
}

function doPost(e) {
  try {
    const body = e.postData?.contents ? JSON.parse(e.postData.contents) : {};
    const action = String(body.action || '').toLowerCase();
    const payload = body.payload || {};

    // Optional auth
    if (WRITE_TOKEN && String(payload.token || '') !== WRITE_TOKEN) {
      return jsonOutput({ ok: false, error: 'Unauthorized' });
    }

    if (action === 'add') return jsonOutput(addRisk(payload));
    if (action === 'update') return jsonOutput(updateRisk(payload));
    if (action === 'delete') return jsonOutput(deleteRisk(payload));

    return jsonOutput({ ok: false, error: 'Unknown action' });
  } catch (err) {
    return jsonOutput({ ok: false, error: String(err) });
  }
}

function jsonOutput(obj) {
  return ContentService
    .createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

/* -------------------------
   Sheets helpers
-------------------------- */
function getSheet_() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sh = ss.getSheetByName(SHEET_NAME);
  if (!sh) sh = ss.insertSheet(SHEET_NAME);

  if (sh.getLastRow() === 0) {
    sh.appendRow([
      'ID', 'Risk', 'Category', 'Owner', 'Probability', 'Impact', 'Score', 'Level',
      'Mitigation', 'Status', 'ReviewDate', 'SourceEvidence', 'LastUpdated', 'UpdatedBy'
    ]);
    sh.getRange(1, 1, 1, 14)
      .setFontWeight('bold')
      .setBackground('#1e3a5f')
      .setFontColor('#ffffff');
    sh.setFrozenRows(1);
  }
  return sh;
}

function getLibSheet_() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  return ss.getSheetByName(LIB_SHEET);
}

function getMasterSheet_() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  return ss.getSheetByName(MASTER_SHEET);
}

function clamp_(n, min, max) {
  n = Number(n);
  if (Number.isNaN(n)) n = min;
  return Math.max(min, Math.min(max, n));
}

function levelFromScore_(score) {
  if (score >= 16) return { key: 'ext', label: 'حرج' };
  if (score >= 12) return { key: 'high', label: 'عالي' };
  if (score >= 6)  return { key: 'med', label: 'متوسط' };
  return { key: 'low', label: 'منخفض' };
}

function findRowById_(sh, id) {
  const finder = sh.createTextFinder(id).matchEntireCell(true).findNext();
  return finder ? finder.getRow() : -1;
}

/* -------------------------
   READ APIs
-------------------------- */
function listRisks() {
  const sh = getSheet_();
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return { ok: true, items: [] };

  const values = sh.getRange(2, 1, lastRow - 1, 14).getValues();

  const items = values.map(r => ({
    id: r[0],
    risk: r[1],
    category: r[2],
    owner: r[3],
    probability: Number(r[4]) || 1,
    impact: Number(r[5]) || 1,
    score: Number(r[6]) || (Number(r[4]) || 1) * (Number(r[5]) || 1),
    level: r[7] || levelFromScore_((Number(r[4]) || 1) * (Number(r[5]) || 1)).label,
    mitigation: r[8],
    status: r[9],
    reviewDate: r[10],
    sourceEvidence: r[11],
    lastUpdated: r[12],
    updatedBy: r[13],
  }));

  return { ok: true, items };
}

function getMetrics() {
  const sh = getSheet_();
  const lastRow = sh.getLastRow();
  if (lastRow < 2) {
    return { ok: true, total: 0, ext: 0, high: 0, med: 0, low: 0, open: 0, progress: 0, closed: 0 };
  }

  const values = sh.getRange(2, 1, lastRow - 1, 14).getValues();
  const stats = { total: values.length, ext: 0, high: 0, med: 0, low: 0, open: 0, progress: 0, closed: 0 };

  values.forEach(r => {
    const level = String(r[7] || '').trim();
    const status = String(r[9] || '').trim();

    if (level === 'حرج') stats.ext++;
    else if (level === 'عالي') stats.high++;
    else if (level === 'متوسط') stats.med++;
    else stats.low++;

    if (status === 'مغلق') stats.closed++;
    else if (status === 'قيد المعالجة' || status === 'قيد التنفيذ') stats.progress++;
    else stats.open++;
  });

  return { ok: true, ...stats };
}

function getRiskLibrary() {
  const lib = getLibSheet_();
  if (!lib || lib.getLastRow() < 2) return { ok: true, items: [] };

  // ✅ 4 columns only: Risk | Category | DefaultOwner | DefaultMitigation
  const values = lib.getRange(2, 1, lib.getLastRow() - 1, 4).getValues();
  const items = values
    .filter(r => String(r[0] || '').trim())
    .map(r => ({
      risk: String(r[0] || '').trim(),
      category: String(r[1] || '').trim(),
      defaultOwner: String(r[2] || '').trim(),
      defaultMitigation: String(r[3] || '').trim(),
    }));

  return { ok: true, items };
}

function getMasterList() {
  const sh = getMasterSheet_();
  if (!sh || sh.getLastRow() < 2) return { ok: true, owners: [], departments: [], pairs: [] };

  // Expect Master: Owner | Department
  const values = sh.getRange(2, 1, sh.getLastRow() - 1, 2).getValues();
  const pairs = values
    .filter(r => String(r[0] || '').trim())
    .map(r => ({ owner: String(r[0] || '').trim(), department: String(r[1] || '').trim() }));

  const owners = Array.from(new Set(pairs.map(p => p.owner))).sort();
  const departments = Array.from(new Set(pairs.map(p => p.department).filter(Boolean))).sort();

  return { ok: true, owners, departments, pairs };
}

/* -------------------------
   WRITE APIs
-------------------------- */
function addRisk(p) {
  const sh = getSheet_();

  const prob = clamp_(p.probability, 1, 5);
  const impact = clamp_(p.impact, 1, 5);
  const score = prob * impact;
  const lvl = levelFromScore_(score).label;

  const id = 'R-' + Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyyMMdd-HHmmss');

  sh.appendRow([
    id,
    String(p.risk || ''),
    String(p.category || ''),
    String(p.owner || ''),
    prob,
    impact,
    score,
    lvl,
    String(p.mitigation || ''),
    String(p.status || 'مفتوح'),
    String(p.reviewDate || ''),
    String(p.sourceEvidence || ''),
    new Date().toISOString(),
    String(p.updatedBy || 'system')
  ]);

  return { ok: true, id };
}

function updateRisk(p) {
  const sh = getSheet_();
  const id = String(p.id || '').trim();
  if (!id) return { ok: false, error: 'Missing id' };

  const row = findRowById_(sh, id);
  if (row === -1) return { ok: false, error: 'ID not found' };

  const prob = clamp_(p.probability, 1, 5);
  const impact = clamp_(p.impact, 1, 5);
  const score = prob * impact;
  const lvl = levelFromScore_(score).label;

  // Write columns 2..14 (13 columns)
  sh.getRange(row, 2, 1, 13).setValues([[
    String(p.risk || ''),
    String(p.category || ''),
    String(p.owner || ''),
    prob,
    impact,
    score,
    lvl,
    String(p.mitigation || ''),
    String(p.status || 'مفتوح'),
    String(p.reviewDate || ''),
    String(p.sourceEvidence || ''),
    new Date().toISOString(),
    String(p.updatedBy || 'system')
  ]]);

  return { ok: true };
}

function deleteRisk(p) {
  const sh = getSheet_();
  const id = String(p.id || '').trim();
  if (!id) return { ok: false, error: 'Missing id' };

  const row = findRowById_(sh, id);
  if (row === -1) return { ok: false, error: 'ID not found' };

  sh.deleteRow(row);
  return { ok: true };
}


هذا الكود يحل:

metrics endpoint ✅

library schema 4 columns ✅

master endpoint ✅

بحث ID سريع وموثوق ✅

جاهز للحماية token (اختياري) ✅

✅ باتشات “ضرورية” للـ Frontend (لا أعيد كتابة الملف كامل)

طبّق هذه التعديلات داخل <script>:

(1) إصلاح setSaveBadge (لا تكسر الكلاسات)

بدّل دالتك الحالية بـ:

function setSaveBadge(type, html) {
  const el = document.getElementById('saveBadge');
  el.innerHTML = html;
  el.classList.remove('ok','warn','err','local');
  el.classList.add(type);
}

(2) لا تولّد ID محلي إذا API موجود

في submit عندك الآن تعمل:

id: editId || 'R-' + Date.now()


التعديل الصحيح:

لو إضافة جديدة و API شغال: لا ترسل id أصلًا، خليه Backend يولده ويرجعه

بعد add خذ data.id ورجّع تحميل السجل

استبدل جزء الإرسال في submit بهذا:

const editId = document.getElementById('editId').value;
const score = probability * impact;

const payload = {
  id: editId || undefined,
  risk: document.getElementById('riskDesc').value,
  category: document.getElementById('category').value,
  owner: document.getElementById('owner').value,
  probability,
  impact,
  mitigation: document.getElementById('mitigation').value,
  status: document.getElementById('status').value,
  reviewDate: document.getElementById('reviewDate').value,
  sourceEvidence: document.getElementById('source').value,
  updatedBy: 'user'
};

const action = editId ? 'update' : 'add';
if (!editId) delete payload.id;


ثم بعد POST:

const res = await fetch(API_URL, {
  method: 'POST',
  headers: { 'Content-Type': 'text/plain;charset=utf-8' },
  body: JSON.stringify({ action, payload })
});
const data = await res.json();

if (!data.ok) throw new Error(data.error || 'Save failed');

setSaveBadge('ok', '<i class="fas fa-cloud-check"></i> تم الحفظ ✓');
await loadRisks(); // مهم جدًا عشان تجيب ID الحقيقي

(3) في delete: تأكد تحذف من السيرفر ثم تعيد تحميل

استبدل deleteRisk بـ:

async function deleteRisk(id) {
  if (!confirm('هل أنت متأكد من حذف هذا الخطر؟')) return;

  setSaveBadge('warn', '<i class="fas fa-spinner fa-spin"></i> جاري الحذف...');

  // محلي
  allRisks = allRisks.filter(r => r.id !== id);
  saveToLocalStorage();

  // سيرفر
  if (API_URL && !useLocalStorage) {
    try {
      const res = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'text/plain;charset=utf-8' },
        body: JSON.stringify({ action: 'delete', payload: { id } })
      });
      const data = await res.json();
      if (!data.ok) throw new Error(data.error || 'Delete failed');
      setSaveBadge('ok', '<i class="fas fa-cloud-check"></i> تم الحذف ✓');
      await loadRisks();
      return;
    } catch (e) {
      setSaveBadge('local', '<i class="fas fa-database"></i> حذف محلي (تعذر السيرفر)');
    }
  } else {
    setSaveBadge('ok', '<i class="fas fa-check-circle"></i> تم الحذف ✓');
  }

  showToast('تم الحذف بنجاح', 'success');
  updateStats();
  applyFilters();
  renderHeatmap();
  checkCriticalAlert();
}

✅ إضافة “ديناميكية القوائم” من Master & RiskLibrary (مهم جدًا للتسهيل)

بعد loadRisks()، قبل تحديث الجدول، نجيب library + master:

أضف دالتين:

async function loadMasterAndLibrary() {
  if (!API_URL) return;

  // Master
  const mRes = await fetch(API_URL + '?action=master');
  const mData = await mRes.json();
  if (mData.ok) {
    fillSelect('owner', mData.owners || [], 'اختر المسؤول...');
  }

  // Library
  const lRes = await fetch(API_URL + '?action=library');
  const lData = await lRes.json();
  if (lData.ok) {
    // نخلي riskDesc Dropdown بدل textarea إذا تحب (أفضل)
    // أو نتركها الآن ونستفيد منها للـ auto-fill
    window.RISK_LIBRARY = lData.items || [];
  }
}

function fillSelect(selectId, items, placeholder) {
  const sel = document.getElementById(selectId);
  if (!sel) return;
  const current = sel.value;
  sel.innerHTML = `<option value="">${placeholder}</option>` + items.map(x => `<option value="${x}">${x}</option>`).join('');
  if (items.includes(current)) sel.value = current;
}


ثم في init() بعد loadRisks() أضف:

loadMasterAndLibrary().catch(()=>{});


والخطوة الذهبية:
لما يكتب/يختار الخطر، تعبّي category و mitigation تلقائيًا من المكتبة:

function autoFillFromLibrary(riskText) {
  const lib = window.RISK_LIBRARY || [];
  const found = lib.find(x => x.risk === riskText);
  if (!found) return;
  if (!document.getElementById('category').value) document.getElementById('category').value = found.category || '';
  if (!document.getElementById('mitigation').value) document.getElementById('mitigation').value = found.defaultMitigation || '';
  if (!document.getElementById('owner').value) document.getElementById('owner').value = found.defaultOwner || '';
}


وبداخل submit أو عند تغيير وصف الخطر (إذا حولته Dropdown أفضل).

التقييم بعد الإصلاحات

بعد هذه الإصلاحات يصبح النظام:

مزامنة صحيحة 100% (IDs حقيقية من السيرفر)

CORS/POST مستقر

قوائم ديناميكية (Master/RiskLibrary)

Metrics endpoint جاهز

Library Schema صحيح

ويصير تقييمه 97/100 (الـ 3% الباقية لو تبغى: Passcode/Login + Logs).