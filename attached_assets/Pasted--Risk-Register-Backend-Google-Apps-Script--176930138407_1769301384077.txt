/**
 * Risk Register Backend - Google Apps Script
 * مجمع مكة الطبي بالزاهر
 * نظام سجل المخاطر مع التعليقات والقرارات
 */

const SPREADSHEET_ID = '12rii0-wE4jXD2NHS6n_6vutMiPOkTkv-A8WrCqlPo6A';
const RISK_SHEET_NAME = 'RiskRegister';
const COMMENTS_SHEET_NAME = 'Comments';
const DECISIONS_SHEET_NAME = 'Decisions';
const RISK_LIBRARY_SHEET_NAME = 'RiskLibrary';

function doGet(e) {
  return handleRequest(e);
}

function doPost(e) {
  return handleRequest(e);
}

function handleRequest(e) {
  try {
    let data;
    if (e.postData) {
      data = JSON.parse(e.postData.contents);
    } else if (e.parameter && e.parameter.action) {
      data = e.parameter;
    } else {
      data = { action: 'getRisks' };
    }
    
    const action = data.action || 'getRisks';
    let result;
    
    switch (action) {
      case 'getRisks':
      case 'list':
        result = getRisks();
        break;
      case 'metrics':
        result = getMetrics();
        break;
      case 'saveRisk':
        result = saveRisk(data.payload || data);
        break;
      case 'updateRisk':
        result = updateRisk(data.payload || data);
        break;
      case 'deleteRisk':
        result = deleteRisk(data.payload?.id || data.id);
        break;
      case 'addComment':
        result = addComment(data.payload);
        break;
      case 'addDecision':
        result = addDecision(data.payload);
        break;
      case 'getComments':
        result = getComments(data.payload?.id || data.id);
        break;
      case 'getDecisions':
        result = getDecisions(data.payload?.id || data.id);
        break;
      case 'getManagers':
        result = getManagers();
        break;
      case 'master':
        result = getMasterData();
        break;
      case 'library':
        result = getLibraryData();
        break;
      default:
        result = { success: false, error: 'Unknown action: ' + action };
    }
    
    return ContentService.createTextOutput(JSON.stringify(result))
      .setMimeType(ContentService.MimeType.JSON);
      
  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: error.message
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

function getMetrics() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(RISK_SHEET_NAME);
  
  if (!sheet || sheet.getLastRow() <= 1) {
    return { ok: true, success: true, total: 0, high: 0, med: 0, low: 0, resolved: 0 };
  }
  
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const levelIdx = headers.indexOf('Level');
  const statusIdx = headers.indexOf('Status');
  
  let total = 0, high = 0, med = 0, low = 0, resolved = 0;
  
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    if (!row[0]) continue;
    total++;
    const level = row[levelIdx] || '';
    const status = row[statusIdx] || '';
    
    if (status === 'مغلق') {
      resolved++;
    } else {
      if (level === 'حرج' || level === 'عالي') high++;
      else if (level === 'متوسط') med++;
      else if (level === 'منخفض') low++;
    }
  }
  
  return { ok: true, success: true, total: total, high: high, med: med, low: low, resolved: resolved, open: high + med + low };
}

function getOrCreateSheet(sheetName, headers) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sheet = ss.getSheetByName(sheetName);
  
  if (!sheet) {
    sheet = ss.insertSheet(sheetName);
    sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
    sheet.getRange(1, 1, 1, headers.length).setFontWeight('bold');
    sheet.setFrozenRows(1);
  }
  
  return sheet;
}

function getRisks() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const riskSheet = ss.getSheetByName(RISK_SHEET_NAME);
  if (!riskSheet) {
    return { success: true, ok: true, data: [] };
  }
  
  const data = riskSheet.getDataRange().getValues();
  if (data.length <= 1) {
    return { success: true, ok: true, data: [] };
  }
  
  const commentsMap = {};
  const decisionsMap = {};
  
  const commentsSheet = ss.getSheetByName(COMMENTS_SHEET_NAME);
  if (commentsSheet && commentsSheet.getLastRow() > 1) {
    const commentsData = commentsSheet.getDataRange().getValues();
    for (let i = 1; i < commentsData.length; i++) {
      const riskId = commentsData[i][0];
      if (!riskId) continue;
      if (!commentsMap[riskId]) commentsMap[riskId] = [];
      commentsMap[riskId].push({
        id: commentsData[i][1],
        text: commentsData[i][2],
        author: commentsData[i][3],
        date: commentsData[i][4]
      });
    }
  }
  
  const decisionsSheet = ss.getSheetByName(DECISIONS_SHEET_NAME);
  if (decisionsSheet && decisionsSheet.getLastRow() > 1) {
    const decisionsData = decisionsSheet.getDataRange().getValues();
    for (let i = 1; i < decisionsData.length; i++) {
      const riskId = decisionsData[i][0];
      if (!riskId) continue;
      if (!decisionsMap[riskId]) decisionsMap[riskId] = [];
      decisionsMap[riskId].push({
        id: decisionsData[i][1],
        text: decisionsData[i][2],
        type: decisionsData[i][3],
        author: decisionsData[i][4],
        date: decisionsData[i][5]
      });
    }
  }
  
  const headerRow = data[0];
  const risks = [];
  
  const headerMap = {
    'ID': 'id', 'Risk': 'risk', 'Category': 'category', 'Owner': 'owner',
    'Probability': 'probability', 'Impact': 'impact', 'Score': 'score', 'Level': 'level',
    'Mitigation': 'mitigation', 'Status': 'status', 'SourceEvidence': 'sourceEvidence',
    'ReviewDate': 'reviewDate', 'NegativeImpact': 'negativeImpact', 'LastUpdated': 'lastUpdated',
    'UpdatedBy': 'updatedBy'
  };
  
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    if (!row[0]) continue;
    
    const risk = {};
    headerRow.forEach((header, idx) => {
      const key = headerMap[header] || header.toLowerCase();
      risk[key] = row[idx];
    });
    
    risk.comments = commentsMap[risk.id] || [];
    risk.decisions = decisionsMap[risk.id] || [];
    
    risks.push(risk);
  }
  
  return { success: true, ok: true, data: risks };
}

function ensureColumnsExist(sheet, requiredHeaders) {
  const existingHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const missingHeaders = requiredHeaders.filter(h => !existingHeaders.includes(h));
  
  if (missingHeaders.length > 0) {
    const lastCol = sheet.getLastColumn();
    missingHeaders.forEach((header, idx) => {
      sheet.getRange(1, lastCol + idx + 1).setValue(header).setFontWeight('bold');
    });
  }
  
  return sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
}

function saveRisk(riskData) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sheet = ss.getSheetByName(RISK_SHEET_NAME);
  
  const requiredHeaders = ['ID', 'Risk', 'Category', 'Owner', 'Probability', 'Impact', 'Score', 'Level', 
                   'Mitigation', 'Status', 'ReviewDate', 'SourceEvidence', 'NegativeImpact', 'LastUpdated', 'UpdatedBy'];
  
  if (!sheet) {
    sheet = ss.insertSheet(RISK_SHEET_NAME);
    sheet.getRange(1, 1, 1, requiredHeaders.length).setValues([requiredHeaders]);
    sheet.getRange(1, 1, 1, requiredHeaders.length).setFontWeight('bold');
    sheet.setFrozenRows(1);
  }
  
  const headers = ensureColumnsExist(sheet, requiredHeaders);
  const id = riskData.id || 'R-' + new Date().getTime();
  const now = new Date().toISOString();
  
  const prob = parseInt(riskData.probability) || 3;
  const imp = parseInt(riskData.impact) || 3;
  const score = prob * imp;
  const level = score >= 20 ? 'حرج' : score >= 12 ? 'عالي' : score >= 6 ? 'متوسط' : 'منخفض';
  
  const dataMap = {
    'ID': id,
    'Risk': riskData.risk || '',
    'Category': riskData.category || '',
    'Owner': riskData.owner || '',
    'Probability': prob,
    'Impact': imp,
    'Score': score,
    'Level': level,
    'Mitigation': riskData.mitigation || '',
    'Status': riskData.status || 'مفتوح',
    'ReviewDate': riskData.reviewDate || '',
    'SourceEvidence': riskData.sourceEvidence || '',
    'NegativeImpact': riskData.negativeImpact || '',
    'LastUpdated': now,
    'UpdatedBy': 'user'
  };
  
  const row = headers.map(h => dataMap[h] || '');
  sheet.appendRow(row);
  
  return { success: true, ok: true, id: id, message: 'تم حفظ الخطر بنجاح' };
}

function updateRisk(riskData) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(RISK_SHEET_NAME);
  if (!sheet) {
    return saveRisk(riskData);
  }
  
  const requiredHeaders = ['ID', 'Risk', 'Category', 'Owner', 'Probability', 'Impact', 'Score', 'Level', 
                   'Mitigation', 'Status', 'ReviewDate', 'SourceEvidence', 'NegativeImpact', 'LastUpdated', 'UpdatedBy'];
  const headers = ensureColumnsExist(sheet, requiredHeaders);
  
  const data = sheet.getDataRange().getValues();
  
  let idIndex = headers.indexOf('ID');
  if (idIndex === -1) idIndex = headers.indexOf('id');
  if (idIndex === -1) {
    return { success: false, error: 'لم يتم العثور على عمود المعرف' };
  }
  
  let rowIndex = -1;
  for (let i = 1; i < data.length; i++) {
    if (data[i][idIndex] === riskData.id) {
      rowIndex = i + 1;
      break;
    }
  }
  
  if (rowIndex === -1) {
    return saveRisk(riskData);
  }
  
  const now = new Date().toISOString();
  const prob = parseInt(riskData.probability) || 3;
  const imp = parseInt(riskData.impact) || 3;
  const score = prob * imp;
  const level = score >= 20 ? 'حرج' : score >= 12 ? 'عالي' : score >= 6 ? 'متوسط' : 'منخفض';
  
  const headerMap = {
    'ID': 'id', 'Risk': 'risk', 'Category': 'category', 'Owner': 'owner',
    'Probability': 'probability', 'Impact': 'impact', 'Score': 'score', 'Level': 'level',
    'Mitigation': 'mitigation', 'Status': 'status', 'SourceEvidence': 'sourceEvidence',
    'ReviewDate': 'reviewDate', 'NegativeImpact': 'negativeImpact', 'LastUpdated': 'lastUpdated'
  };
  
  const updates = {
    risk: riskData.risk,
    category: riskData.category,
    owner: riskData.owner,
    probability: prob,
    impact: imp,
    score: score,
    level: level,
    mitigation: riskData.mitigation,
    status: riskData.status,
    sourceEvidence: riskData.sourceEvidence,
    reviewDate: riskData.reviewDate,
    negativeImpact: riskData.negativeImpact,
    lastUpdated: now
  };
  
  headers.forEach((header, colIndex) => {
    const key = headerMap[header] || header.toLowerCase();
    if (updates.hasOwnProperty(key)) {
      sheet.getRange(rowIndex, colIndex + 1).setValue(updates[key]);
    }
  });
  
  return { success: true, ok: true, id: riskData.id, message: 'تم تحديث الخطر بنجاح' };
}

function deleteRisk(id) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(RISK_SHEET_NAME);
  if (!sheet) {
    return { success: false, error: 'لم يتم العثور على الورقة' };
  }
  
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  let idIndex = headers.indexOf('ID');
  if (idIndex === -1) idIndex = headers.indexOf('id');
  if (idIndex === -1) {
    return { success: false, error: 'لم يتم العثور على عمود المعرف' };
  }
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][idIndex] === id) {
      sheet.deleteRow(i + 1);
      deleteCommentsForRisk(id);
      deleteDecisionsForRisk(id);
      return { success: true, ok: true, message: 'تم حذف الخطر بنجاح' };
    }
  }
  
  return { success: false, error: 'لم يتم العثور على الخطر' };
}

function addComment(payload) {
  const headers = ['riskId', 'commentId', 'text', 'author', 'date'];
  const sheet = getOrCreateSheet(COMMENTS_SHEET_NAME, headers);
  
  const commentId = 'C-' + new Date().getTime();
  const comment = payload.comment;
  
  const row = [
    payload.id,
    commentId,
    comment.text || '',
    comment.author || 'مستخدم',
    comment.date || new Date().toISOString()
  ];
  
  sheet.appendRow(row);
  
  return { success: true, ok: true, commentId: commentId, message: 'تم إضافة التعليق بنجاح' };
}

function getComments(riskId) {
  const headers = ['riskId', 'commentId', 'text', 'author', 'date'];
  const sheet = getOrCreateSheet(COMMENTS_SHEET_NAME, headers);
  
  const data = sheet.getDataRange().getValues();
  if (data.length <= 1) {
    return { success: true, ok: true, data: [] };
  }
  
  const comments = [];
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === riskId) {
      comments.push({
        id: data[i][1],
        text: data[i][2],
        author: data[i][3],
        date: data[i][4]
      });
    }
  }
  
  return { success: true, ok: true, data: comments };
}

function deleteCommentsForRisk(riskId) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(COMMENTS_SHEET_NAME);
  if (!sheet) return;
  const data = sheet.getDataRange().getValues();
  
  for (let i = data.length - 1; i >= 1; i--) {
    if (data[i][0] === riskId) {
      sheet.deleteRow(i + 1);
    }
  }
}

function addDecision(payload) {
  const headers = ['riskId', 'decisionId', 'text', 'type', 'author', 'date'];
  const sheet = getOrCreateSheet(DECISIONS_SHEET_NAME, headers);
  
  const decisionId = 'D-' + new Date().getTime();
  const decision = payload.decision;
  
  const row = [
    payload.id,
    decisionId,
    decision.text || '',
    decision.type || 'آخر',
    decision.author || 'مستخدم',
    decision.date || new Date().toISOString()
  ];
  
  sheet.appendRow(row);
  
  return { success: true, ok: true, decisionId: decisionId, message: 'تم إضافة القرار بنجاح' };
}

function getDecisions(riskId) {
  const headers = ['riskId', 'decisionId', 'text', 'type', 'author', 'date'];
  const sheet = getOrCreateSheet(DECISIONS_SHEET_NAME, headers);
  
  const data = sheet.getDataRange().getValues();
  if (data.length <= 1) {
    return { success: true, ok: true, data: [] };
  }
  
  const decisions = [];
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === riskId) {
      decisions.push({
        id: data[i][1],
        text: data[i][2],
        type: data[i][3],
        author: data[i][4],
        date: data[i][5]
      });
    }
  }
  
  return { success: true, ok: true, data: decisions };
}

function deleteDecisionsForRisk(riskId) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(DECISIONS_SHEET_NAME);
  if (!sheet) return;
  const data = sheet.getDataRange().getValues();
  
  for (let i = data.length - 1; i >= 1; i--) {
    if (data[i][0] === riskId) {
      sheet.deleteRow(i + 1);
    }
  }
}

function getManagers() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Master');
  
  if (!sheet) {
    return { success: true, ok: true, data: [] };
  }
  
  const data = sheet.getDataRange().getValues();
  const managers = [];
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][0]) {
      managers.push({
        name: data[i][0],
        department: data[i][1] || ''
      });
    }
  }
  
  return { success: true, ok: true, data: managers };
}

function getMasterData() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Master');
  
  if (!sheet) {
    return { success: true, ok: true, owners: [], departments: [], sources: [] };
  }
  
  const data = sheet.getDataRange().getValues();
  const owners = [];
  const departments = [];
  const sources = [];
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][0]) owners.push(data[i][0]);
    if (data[i][1] && !departments.includes(data[i][1])) departments.push(data[i][1]);
    if (data[i][2] && !sources.includes(data[i][2])) sources.push(data[i][2]);
  }
  
  return { success: true, ok: true, owners: owners, departments: departments, sources: sources };
}

function getLibraryData() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(RISK_LIBRARY_SHEET_NAME);
  
  if (!sheet) {
    return { success: true, ok: true, data: [], items: [] };
  }
  
  const data = sheet.getDataRange().getValues();
  const items = [];
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][0]) {
      items.push({
        risk: data[i][0],
        category: data[i][1] || '',
        defaultOwner: data[i][2] || '',
        defaultMitigation: data[i][3] || ''
      });
    }
  }
  
  return { success: true, ok: true, data: items, items: items };
}